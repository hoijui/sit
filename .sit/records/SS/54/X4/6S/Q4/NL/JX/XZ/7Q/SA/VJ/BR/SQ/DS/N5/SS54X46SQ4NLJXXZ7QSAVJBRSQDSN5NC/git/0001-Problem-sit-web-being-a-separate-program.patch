From 08163d7664034c1b0388c1d64978b0cbb96ac428 Mon Sep 17 00:00:00 2001
From: Yurii Rashkovskii <me@yrashk.com>
Date: Tue, 2 Oct 2018 20:53:42 -0700
Subject: [PATCH] Problem: sit web being a separate program

Currently, `sit web` is distributed as a separate program. It has a few
downsides:

1. It is confusing in terms of distribution. Which tool does the user
need?
2. It has a bunch of business logic copied nearly verbatim from `sit`
(figuring out where a repository should be, etc.)

Solution: integrate it into the main program
---
 Cargo.lock                          | 172 ++++--------
 Cargo.toml                          |   2 +-
 sit-web/.gitignore                  |   2 -
 sit-web/Cargo.toml                  |  39 ---
 sit-web/README.md                   |  12 -
 sit-web/src/main.rs                 | 141 ----------
 sit-web/src/webapp.rs               | 498 ----------------------------------
 sit/Cargo.toml                      |  14 +-
 {sit-web => sit}/build.rs           |   2 +-
 sit/src/command_web.rs              | 516 ++++++++++++++++++++++++++++++++++++
 sit/src/main.rs                     |  55 +++-
 {sit-web => sit}/webapp/favicon.ico | Bin
 {sit-web => sit}/webapp/index.html  |   0
 13 files changed, 625 insertions(+), 828 deletions(-)
 delete mode 100644 sit-web/.gitignore
 delete mode 100644 sit-web/Cargo.toml
 delete mode 100644 sit-web/README.md
 delete mode 100644 sit-web/src/main.rs
 delete mode 100644 sit-web/src/webapp.rs
 rename {sit-web => sit}/build.rs (86%)
 create mode 100644 sit/src/command_web.rs
 rename {sit-web => sit}/webapp/favicon.ico (100%)
 rename {sit-web => sit}/webapp/index.html (100%)

diff --git a/Cargo.lock b/Cargo.lock
index ca376c75..64dc8661 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -34,7 +34,7 @@ dependencies = [
 
 [[package]]
 name = "ascii"
-version = "0.7.1"
+version = "0.8.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -75,11 +75,11 @@ dependencies = [
 
 [[package]]
 name = "base64"
-version = "0.7.0"
+version = "0.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "byteorder 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "safemem 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -121,19 +121,19 @@ dependencies = [
 
 [[package]]
 name = "brotli-sys"
-version = "0.2.1"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cc 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "brotli2"
-version = "0.2.2"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "brotli-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "brotli-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -181,15 +181,6 @@ name = "cfg-if"
 version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
-[[package]]
-name = "chrono"
-version = "0.2.25"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "chrono"
 version = "0.4.2"
@@ -476,7 +467,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "filetime"
-version = "0.1.15"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -503,11 +494,6 @@ name = "fuchsia-zircon-sys"
 version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
-[[package]]
-name = "gcc"
-version = "0.3.54"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
 [[package]]
 name = "generic-array"
 version = "0.9.0"
@@ -763,16 +749,6 @@ dependencies = [
  "memchr 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
-[[package]]
-name = "num"
-version = "0.1.42"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-iter 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "num-integer"
 version = "0.1.36"
@@ -781,15 +757,6 @@ dependencies = [
  "num-traits 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
-[[package]]
-name = "num-iter"
-version = "0.1.35"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "num-traits"
 version = "0.1.43"
@@ -1017,25 +984,25 @@ dependencies = [
 
 [[package]]
 name = "rouille"
-version = "2.1.0"
+version = "2.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "base64 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "brotli2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "brotli2 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "chrono 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "deflate 0.7.18 (registry+https://github.com/rust-lang/crates.io-index)",
- "filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)",
+ "filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "multipart 0.13.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde_derive 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde_json 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)",
- "sha1 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "term 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sha1 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "time 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "tiny_http 0.5.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tiny_http 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -1045,13 +1012,13 @@ version = "0.1.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
-name = "rustc-serialize"
-version = "0.3.24"
+name = "safemem"
+version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "safemem"
-version = "0.2.0"
+version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -1140,7 +1107,7 @@ dependencies = [
 
 [[package]]
 name = "sha1"
-version = "0.2.0"
+version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -1153,23 +1120,31 @@ name = "sit"
 version = "0.5.0-pre"
 dependencies = [
  "atty 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "blake2 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "chrono 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "cli_test_dir 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
  "config 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "derive-error 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "digest 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "directories 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "dunce 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "git2 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "include_dir 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
  "itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "jmespath 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mime_guess 1.8.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "pbr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "question 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rouille 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_derive 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde_json 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)",
  "sit-core 0.5.0-pre",
  "tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -1211,36 +1186,6 @@ dependencies = [
  "walkdir 2.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
-[[package]]
-name = "sit-web"
-version = "0.5.0-pre"
-dependencies = [
- "blake2 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "chrono 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "config 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "digest 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "directories 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "include_dir 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "jmespath 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "mime_guess 1.8.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "rouille 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_json 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)",
- "sit 0.5.0-pre",
- "sit-core 0.5.0-pre",
- "tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "tempfile 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "thread_local 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "which 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "slug"
 version = "0.1.3"
@@ -1314,11 +1259,11 @@ dependencies = [
 
 [[package]]
 name = "term"
-version = "0.2.14"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "byteorder 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -1385,15 +1330,15 @@ dependencies = [
 
 [[package]]
 name = "tiny_http"
-version = "0.5.9"
+version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "ascii 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "chrono 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ascii 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "chrono 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "chunked_transfer 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "encoding 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "url 0.2.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -1475,16 +1420,6 @@ dependencies = [
  "void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
-[[package]]
-name = "url"
-version = "0.2.38"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
- "uuid 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "url"
 version = "1.7.0"
@@ -1500,15 +1435,6 @@ name = "utf8-ranges"
 version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
-[[package]]
-name = "uuid"
-version = "0.1.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "uuid"
 version = "0.5.1"
@@ -1603,19 +1529,19 @@ dependencies = [
 "checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b"
 "checksum arrayref 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "0fd1479b7c29641adbd35ff3b5c293922d696a92f25c8c975da3e0acbc87258f"
 "checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)" = "a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef"
-"checksum ascii 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3ae7d751998c189c1d4468cf0a39bb2eae052a9c58d50ebb3b9591ee3813ad50"
+"checksum ascii 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)" = "97be891acc47ca214468e09425d02cef3af2c94d0d82081cd02061f996802f14"
 "checksum assert_matches 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "664470abf00fae0f31c0eb6e1ca12d82961b2a2541ef898bc9dd51a9254d218b"
 "checksum atty 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)" = "6609a866dd1a1b2d0ee1362195bf3e4f6438abb2d80120b83b1e1f4fb6476dd0"
 "checksum backtrace 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)" = "ebbe525f66f42d207968308ee86bc2dd60aa5fab535b22e616323a173d097d8e"
 "checksum backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)" = "44585761d6161b0f57afc49482ab6bd067e4edef48c12a152c237eb0203f7661"
-"checksum base64 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5032d51da2741729bfdaeb2664d9b8c6d9fd1e2b90715c660b6def36628499c2"
+"checksum base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)" = "489d6c0ed21b11d038c31b6ceccca973e65d73ba3bd8ecb9a2babf5546164643"
 "checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a"
 "checksum bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "4440d5cb623bb7390ae27fec0bb6c61111969860f8e3ae198bfa0663645e67cf"
 "checksum bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "b3c30d3802dfb7281680d6285f2ccdaa8c2d8fee41f93805dba5c4cf50dc23cf"
 "checksum blake2 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b0da79fe9391e02df251e0d86197332d398b4721e80722fc91b9c4cbde3ce355"
 "checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab"
-"checksum brotli-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cb50f54b2e0c671b7ef1637a76237ebacbb293be179440d5d65ca288e42116bb"
-"checksum brotli2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "ea9d0bbab1235017a09226b079ed733bca4bf9ecb6b6102bd01aac79ea082dca"
+"checksum brotli-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "4445dea95f4c2b41cde57cc9fee236ae4dbae88d8fcbdb4750fc1bb5d86aaecd"
+"checksum brotli2 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "0cb036c3eade309815c15ddbacec5b22c4d1f3983a774ab2eac2e3e9ea85568e"
 "checksum buf_redux 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)" = "b9279646319ff816b05fb5897883ece50d7d854d12b59992683d4f8a71b0f949"
 "checksum build_const 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "39092a32794787acd8525ee150305ff051b0aa6cc2abaf193924f5ab05425f39"
 "checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40"
@@ -1624,7 +1550,6 @@ dependencies = [
 "checksum cc 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)" = "8b9d2900f78631a5876dc5d6c9033ede027253efcd33dd36b1309fc6cab97ee0"
 "checksum cesu8 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
 "checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de"
-"checksum chrono 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)" = "9213f7cd7c27e95c2b57c49f0e69b1ea65b27138da84a170133fd21b07659c00"
 "checksum chrono 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "1cce36c92cb605414e9b824f866f5babe0a0368e39ea07393b9b63cf3844c0e6"
 "checksum chunked_transfer 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "498d20a7aaf62625b9bf26e637cf7736417cde1d0c99f1d04d1170229a85cf87"
 "checksum clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)" = "f0f16b89cbb9ee36d87483dc939fe9f1e13c05898d56d7b230a0d4dff033a536"
@@ -1659,11 +1584,10 @@ dependencies = [
 "checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82"
 "checksum failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "c7cdda555bb90c9bb67a3b670a0f42de8e73f5981524123ad8578aafec8ddb8b"
 "checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed"
-"checksum filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)" = "714653f3e34871534de23771ac7b26e999651a0a228f47beb324dfdf1dd4b10f"
+"checksum filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "da4b9849e77b13195302c174324b5ba73eec9b236b24c221a61000daefb95c5f"
 "checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674"
 "checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
 "checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"
-"checksum gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)" = "5e33ec290da0d127825013597dbdfc28bee4964690c7ce1166cbc2a7bd08b1bb"
 "checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d"
 "checksum git2 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0f41c0035c37ec11ed3f1e1946a76070b0c740393687e9a9c7612f6a709036b3"
 "checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb"
@@ -1696,9 +1620,7 @@ dependencies = [
 "checksum multipart 0.13.6 (registry+https://github.com/rust-lang/crates.io-index)" = "92f54eb45230c3aa20864ccf0c277eeaeadcf5e437e91731db498dbf7fbe0ec6"
 "checksum nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2"
 "checksum nom 3.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "05aec50c70fd288702bcd93284a8444607f3292dbdf2a30de5ea5dcdbe72287b"
-"checksum num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "4703ad64153382334aa8db57c637364c322d3372e097840c72000dabdcf6156e"
 "checksum num-integer 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)" = "f8d26da319fb45674985c78f1d1caf99aa4941f785d384a2ae36d0740bc3e2fe"
-"checksum num-iter 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)" = "4b226df12c5a59b63569dd57fafb926d91b385dfce33d8074a412411b689d593"
 "checksum num-traits 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)" = "92e5113e9fd4cc14ded8e499429f396a20f98c772a47cc8622a736e1ec843c31"
 "checksum num-traits 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "dee092fcdf725aee04dd7da1d21debff559237d49ef1cb3e69bcb8ece44c7364"
 "checksum num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)" = "c51a3322e4bca9d212ad9a158a02abc6934d005490c054a2778df73a70aa0a30"
@@ -1728,10 +1650,10 @@ dependencies = [
 "checksum regex-syntax 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "8e931c58b93d86f080c734bfd2bce7dd0079ae2331235818133c8be7f422e20e"
 "checksum relative-path 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)" = "e614f96449605730b4f7ad2c019e88c1652d730634b4eba07b810801856635e3"
 "checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5"
-"checksum rouille 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "cc1f8407af80b0630983b2c1f1860dda1960fdec8d3ee75ba8db14937756d3a0"
+"checksum rouille 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "0845b9c39ba772da769fe2aaa4d81bfd10695a7ea051d0510702260ff4159841"
 "checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb"
-"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)" = "dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda"
 "checksum safemem 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e27a8b19b835f7aea908818e871f5cc3a5a186550c30773be987e155e8163d8f"
+"checksum safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "8dca453248a96cb0749e36ccdfe2b0b4e54a61bfef89fb97ec621eb8e0a93dd9"
 "checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637"
 "checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27"
 "checksum serde 0.8.23 (registry+https://github.com/rust-lang/crates.io-index)" = "9dad3f759919b92c3068c696c15c3d17238234498bbdcc80f2c469606f948ac8"
@@ -1742,7 +1664,7 @@ dependencies = [
 "checksum serde_json 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)" = "8c6c4e049dc657a99e394bd85c22acbf97356feeec6dbf44150f2dcf79fb3118"
 "checksum serde_test 0.8.23 (registry+https://github.com/rust-lang/crates.io-index)" = "110b3dbdf8607ec493c22d5d947753282f3bae73c0f56d322af1e8c78e4c23d5"
 "checksum sha-1 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded"
-"checksum sha1 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "cc30b1e1e8c40c121ca33b86c23308a090d19974ef001b4bf6e61fd1a0fb095c"
+"checksum sha1 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "2579985fda508104f7587689507983eadd6a6e84dd35d6d115361f530916fa0d"
 "checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537"
 "checksum slug 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "797bcb4d24e91239a8615415814f4afb2d8ca400c472de3c73f803a5a7689e11"
 "checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550"
@@ -1752,7 +1674,7 @@ dependencies = [
 "checksum synstructure 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3a761d12e6d8dcb4dcf952a7a89b475e3a9d69e4a69307e01a470977642914bd"
 "checksum tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)" = "15f2b5fb00ccdf689e0149d1b1b3c03fead81c2b37735d812fa8bddbbf41b6d8"
 "checksum tempfile 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "11ce2fe9db64b842314052e2421ac61a73ce41b898dc8e3750398b219c5fc1e0"
-"checksum term 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)" = "f2077e54d38055cf1ca0fd7933a2e00cd3ec8f6fed352b2a377f06dcdaaf3281"
+"checksum term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5e6b677dd1e8214ea1ef4297f85dbcbed8e8cdddb561040cc998ca2551c37561"
 "checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096"
 "checksum textwrap 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)" = "c0b59b6b4b44d867f1370ef1bd91bfb262bf07bf0ae65c202ea2fbc16153b693"
 "checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03"
@@ -1760,7 +1682,7 @@ dependencies = [
 "checksum thread_local 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)" = "279ef31c19ededf577bfd12dfae728040a21f635b06a24cd670ff510edd38963"
 "checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865"
 "checksum time 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)" = "a15375f1df02096fb3317256ce2cee6a1f42fc84ea5ad5fc8c421cfe40c73098"
-"checksum tiny_http 0.5.9 (registry+https://github.com/rust-lang/crates.io-index)" = "2f4d55c9a213880d1f0c89ded183f209c6e45b912ca6c7df6f93c163773572e1"
+"checksum tiny_http 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "a442681f9f72e440be192700eeb2861e4174b9983f16f4877c93a134cb5e5f63"
 "checksum toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "a0263c6c02c4db6c8f7681f9fd35e90de799ebd4cfdeab77a38f4ff6b3d8c0d9"
 "checksum twoway 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "59b11b2b5241ba34be09c3cc85a36e56e48f9888862e19cedf23336d35316ed1"
 "checksum typed-builder 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "0a17a8ff0df819694df5f61b1181fc0688b00e2bcd8951f7a5880f192d8b4cd1"
@@ -1773,10 +1695,8 @@ dependencies = [
 "checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
 "checksum unidecode 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "402bb19d8e03f1d1a7450e2bd613980869438e0666331be3e073089124aa1adc"
 "checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56"
-"checksum url 0.2.38 (registry+https://github.com/rust-lang/crates.io-index)" = "cbaa8377a162d88e7d15db0cf110c8523453edcbc5bc66d2b6fffccffa34a068"
 "checksum url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "f808aadd8cfec6ef90e4a14eb46f24511824d1ac596b9682703c87056c8678b7"
 "checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f"
-"checksum uuid 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)" = "78c590b5bd79ed10aad8fb75f078a59d8db445af6c743e55c4a53227fc01c13f"
 "checksum uuid 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "bcc7e3b898aa6f6c08e5295b6c89258d1331e9ac578cc992fb818759951bdc22"
 "checksum vcpkg 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "7ed0f6789c8a85ca41bbc1c9d175422116a9869bd1cf31bb08e1493ecce60380"
 "checksum vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)" = "887b5b631c2ad01628bbbaa7dd4c869f80d3186688f8d0b6f58774fbe324988c"
diff --git a/Cargo.toml b/Cargo.toml
index 2c4d3fcd..dfa78702 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,3 +1,3 @@
 [workspace]
 
-members = ["sit-core", "sit-web", "sit"]
+members = ["sit-core", "sit"]
diff --git a/sit-web/.gitignore b/sit-web/.gitignore
deleted file mode 100644
index 0731e56f..00000000
--- a/sit-web/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-webapp/node_modules
-webapp/documentation
diff --git a/sit-web/Cargo.toml b/sit-web/Cargo.toml
deleted file mode 100644
index acdc8c65..00000000
--- a/sit-web/Cargo.toml
+++ /dev/null
@@ -1,39 +0,0 @@
-[package]
-name = "sit-web"
-version = "0.5.0-pre"
-description = "Serverless Information Tracker Web Interface"
-authors = ["Yurii Rashkovskii <me@yrashk.com>"]
-license = "MIT/Apache-2.0"
-
-[dependencies]
-clap = "2.29"
-chrono = "0.4"
-tempfile = "2.2"
-tempdir = "0.3"
-config = { version = "0.8", features = ["json"] }
-serde = "1.0"
-serde_derive = "1.0"
-serde_json = "1.0"
-jmespath = { version = "0.2", features = ["sync"] }
-rouille = "2.1.0"
-lazy_static = "1.0"
-mime_guess = "1.8"
-itertools = "0.7"
-rayon = "1.0"
-digest = "0.7"
-blake2 = "0.7"
-hex = "0.3"
-which = "2.0"
-thread_local = "0.3"
-directories = "1.0"
-sit-core = { path = "../sit-core", version = "0.5.0-pre", features = ["git"] }
-sit = { path = "../sit", version = "0.5.0-pre" }
-
-[build-dependencies]
-include_dir = "0.1"
-fs_extra = "1.1"
-
-[features]
-default = ["deprecated-items"]
-windows7 = ["sit-core/windows7"]
-deprecated-items = ["sit-core/deprecated-item-api"]
diff --git a/sit-web/README.md b/sit-web/README.md
deleted file mode 100644
index 43773107..00000000
--- a/sit-web/README.md
+++ /dev/null
@@ -1,12 +0,0 @@
-# sit-web
-
-## Development process
-
-In order to enable sit-web to pick up the changes you are
-making to `sit-web/webapp`, run sit-web with an `-o/--overlay`
-argument:
-
-```
-sit-web -o sit-web/webapp
-```
-
diff --git a/sit-web/src/main.rs b/sit-web/src/main.rs
deleted file mode 100644
index daba5c18..00000000
--- a/sit-web/src/main.rs
+++ /dev/null
@@ -1,141 +0,0 @@
-extern crate sit_core;
-extern crate sit;
-
-extern crate chrono;
-extern crate tempfile;
-#[macro_use] extern crate clap;
-
-use std::env;
-use std::path::PathBuf;
-use std::fs;
-use std::process::exit;
-
-use clap::{Arg, App};
-
-extern crate serde;
-extern crate serde_json;
-#[macro_use] extern crate serde_derive;
-
-extern crate config;
-use sit_core::cfg;
-
-extern crate directories;
-
-extern crate jmespath;
-
-extern crate itertools;
-
-extern crate rayon;
-
-extern crate tempdir;
-
-extern crate digest;
-extern crate blake2;
-extern crate hex;
-
-#[macro_use] extern crate lazy_static;
-#[macro_use] extern crate rouille;
-extern crate mime_guess;
-mod webapp;
-
-extern crate which;
-
-use std::ffi::OsString;
-use which::which;
-
-use sit::ScriptModule;
-
-extern crate thread_local;
-
-pub fn gnupg(config: &cfg::Configuration) -> Result<OsString, which::Error> {
-    let program = match config.signing.gnupg {
-            Some(ref command) => command.clone().into(),
-            None => which("gpg2").or_else(|_| which("gpg"))?.to_str().unwrap().into(),
-    };
-    Ok(program)
-}
-
-fn main() {
-    let cwd = env::current_dir().expect("can't get current working directory");
-    let matches = App::new("SIT Web Interface")
-        .version(crate_version!())
-        .about(crate_description!())
-        .settings(&[clap::AppSettings::ColoredHelp, clap::AppSettings::ColorAuto])
-        .arg(Arg::with_name("working_directory")
-            .short("d")
-            .default_value(cwd.to_str().unwrap())
-            .help("Working directory"))
-        .arg(Arg::with_name("repository")
-            .short("r")
-            .long("repository")
-            .takes_value(true)
-            .help("Point to a specific directory of SIT's repository"))
-        .arg(Arg::with_name("verbosity")
-            .short("v")
-            .multiple(true)
-            .help("Sets the level of verbosity"))
-        .arg(Arg::with_name("config")
-            .short("c")
-            .long("config")
-            .takes_value(true)
-            .help("Config file (overrides default)"))
-        .arg(Arg::with_name("readonly")
-             .long("readonly")
-             .help("Read-only instance of sit-web (no new items or records can be created)"))
-        .arg(Arg::with_name("overlay")
-            .short("o")
-            .long("overlay")
-            .takes_value(true)
-            .multiple(true)
-            .help("Path to an additional [besides standard ones] web overlay"))
-        .arg(Arg::with_name("listen")
-            .default_value("127.0.0.1:8080")
-            .help("Listen on IP:PORT"))
-        .get_matches();
-
-    let project_dirs = directories::ProjectDirs::from("fyi", "sit", "sit").expect("can't derive project directories");
-    let default_config = project_dirs.config_dir().join("config.json");
-
-    let config_path = matches.value_of("config").unwrap_or(default_config.to_str().unwrap());
-
-    let mut settings = config::Config::default();
-    settings
-        .merge(config::File::with_name(config_path).required(false)).unwrap();
-
-    let mut config: cfg::Configuration = settings.try_into().expect("can't load config");
-
-    let working_dir = PathBuf::from(matches.value_of("working_directory").unwrap());
-    let canonical_working_dir = fs::canonicalize(&working_dir).expect("can't canonicalize working directory");
-
-    if config.author.is_none() {
-        if let Some(author) = cfg::Author::from_gitconfig(canonical_working_dir.join(".git/config")) {
-            config.author = Some(author);
-        } else if let Some(author) = cfg::Author::from_gitconfig(directories::UserDirs::new().expect("can't identify home directory").home_dir().join(".gitconfig")) {
-            config.author = Some(author);
-        } else {
-            eprintln!("Authorship hasn't been configured. Update your {} config file\n\
-            to include `author` object with `name` and `email` properties specified", config_path);
-            exit(1);
-        }
-    }
-
-    let repo_path = matches.value_of("repository").map(PathBuf::from)
-        .or_else(|| sit_core::Repository::find_in_or_above(".sit",&working_dir))
-        .expect("Can't find a repository");
-    let repo = sit_core::Repository::open(&repo_path)
-        .expect("can't open repository");
-
-    let listen = matches.value_of("listen").unwrap();
-    let readonly = matches.is_present("readonly");
-    let overlays: Vec<_> = matches.values_of("overlay").unwrap_or(clap::Values::default()).collect();
-    println!("Serving on {}", listen);
-    match repo.config().clone().extra().get("module_manager") {
-            Some(serde_json::Value::String(name)) => {
-                let original_repo = repo.clone();
-                let repo = repo.with_module_iterator(ScriptModule(original_repo, cwd.clone(), name.clone()));
-                webapp::start(listen, config, repo, readonly, overlays);
-            },
-            _ => webapp::start(listen, config, repo, readonly, overlays),
-    };
-
-}
diff --git a/sit-web/src/webapp.rs b/sit-web/src/webapp.rs
deleted file mode 100644
index 81df498c..00000000
--- a/sit-web/src/webapp.rs
+++ /dev/null
@@ -1,498 +0,0 @@
-#[allow(dead_code)]
-mod assets {
-    include!(concat!(env!("OUT_DIR"), "/assets.rs"));
-
-    use rouille::{Response, ResponseBody};
-    use mime_guess::get_mime_type_str;
-    use std::path::PathBuf;
-    use blake2::Blake2b;
-    use digest::{Input, VariableOutput};
-    use hex;
-
-    impl<'a> Into<(Response, String)> for &'a File {
-        fn into(self) -> (Response, String) {
-            let mut hasher = Blake2b::new(20).unwrap();
-            let mut result = vec![0; 20];
-            hasher.process(self.contents);
-            let hash = hex::encode(hasher.variable_result(&mut result).unwrap());
-            (match get_mime_type_str(PathBuf::from(self.name()).extension().unwrap().to_str().unwrap()) {
-                None => Response {
-                    status_code: 200,
-                    headers: vec![("Content-Type".into(), "application/octet-stream".into())],
-                    data: ResponseBody::from_data(self.contents),
-                    upgrade: None,
-                },
-                Some(content_type) => Response {
-                    status_code: 200,
-                    headers: vec![("Content-Type".into(), content_type.into())],
-                    data: ResponseBody::from_data(self.contents),
-                    upgrade: None,
-                },
-            }, hash)
-        }
-    }
-
-    use std::collections::HashMap;
-
-    lazy_static! {
-       pub static ref ASSETS: HashMap<PathBuf, File> = {
-         let mut map = HashMap::new();
-         let mut prefix = PathBuf::from(FILES.find("index.html").unwrap().path());
-         prefix.pop();
-         for entry in FILES.walk() {
-            match entry {
-               DirEntry::File(f) => {
-                  let path = PathBuf::from(f.path().strip_prefix(&prefix).unwrap());
-                  map.insert(path.clone(), f.clone());
-                  let super_path = PathBuf::from("super").join(path);
-                  map.insert(super_path, f.clone());
-               },
-               _ => (),
-            }
-         }
-         map
-       };
-    }
-
-}
-use self::assets::ASSETS;
-
-use rouille::{start_server, Request, Response, ResponseBody};
-use rouille::input::multipart::get_multipart_input;
-
-use std::path::PathBuf;
-use std::fs;
-use std::net::ToSocketAddrs;
-
-use sit_core::{Repository, repository, reducers::duktape::{self, DuktapeReducer}, record::OrderedFiles,
-               record::{RecordContainer, RecordContainerReduction, RecordOwningContainer}, path::{HasPath, ResolvePath}};
-use std::io::Cursor;
-
-use mime_guess::get_mime_type_str;
-
-use std::ffi::OsString;
-
-use rayon::prelude::*;
-
-use blake2::Blake2b;
-use digest::{Input, VariableOutput};
-use hex;
-
-use serde_json;
-
-use std::sync::{Arc, Mutex};
-use std::cell::RefCell;
-use thread_local::ThreadLocal;
-
-fn path_to_response<P: Into<PathBuf>>(path: P, request: &Request) -> Response {
-    let path: PathBuf = path.into();
-
-    let mut file = fs::File::open(&path).unwrap();
-    let mut buf = Vec::with_capacity(file.metadata().unwrap().len() as usize);
-    use std::io::Read;
-    file.read_to_end(&mut buf).unwrap();
-
-
-    let mut hasher = Blake2b::new(20).unwrap();
-    let mut result = vec![0; 20];
-    hasher.process(&buf);
-    let hash = hex::encode(hasher.variable_result(&mut result).unwrap());
-
-    match get_mime_type_str(path.extension().unwrap_or(&OsString::new()).to_str().unwrap()) {
-        None => Response {
-            status_code: 200,
-            headers: vec![("Content-Type".into(), "application/octet-stream".into())],
-            data: ResponseBody::from_data(buf),
-            upgrade: None,
-        },
-        Some(content_type) => Response {
-            status_code: 200,
-            headers: vec![("Content-Type".into(), content_type.into())],
-            data: ResponseBody::from_data(buf),
-            upgrade: None,
-        },
-    }.with_etag(request, hash)
-}
-
-
-use itertools::Itertools;
-use sit_core;
-
-#[derive(Serialize)]
-struct Config {
-    readonly: bool,
-}
-
-
-fn new_record<C: RecordOwningContainer, MI>(container: &C, request: &Request, repo: &Repository<MI>, config: &sit_core::cfg::Configuration) -> Result<C::Record, String> {
-    let mut multipart = get_multipart_input(request).expect("multipart request");
-    let mut link = true;
-    let mut used_files = vec![];
-
-    loop {
-        let part = multipart.next();
-        if part.is_none() {
-            break;
-        }
-        let mut field = part.unwrap();
-        loop {
-            let path = {
-                let mut file = field.data.as_file().expect("files only");
-                let saved_file = file.save().temp().into_result().expect("can't save file");
-                saved_file.path
-            };
-            if field.name.starts_with(".prev/") {
-                link = false;
-            }
-            used_files.push((field.name.clone(), path));
-            match field.next_entry_inplace() {
-                Ok(Some(_)) => continue,
-                Ok(None) => break,
-                Err(e) => panic!(e),
-            }
-        }
-    }
-
-    let files: OrderedFiles<_> = used_files.iter().map(|(n, p)| (n.clone(), fs::File::open(p).expect("can't open saved file"))).into();
-    let files_: OrderedFiles<_> = used_files.iter().map(|(n, p)| (n.clone(), fs::File::open(p).expect("can't open saved file"))).into();
-
-    let files: OrderedFiles<_> = if config.signing.enabled {
-        use std::ffi::OsString;
-        use std::io::Write;
-        let program = super::gnupg(&config).unwrap();
-        let key = match config.signing.key.clone() {
-            Some(key) => Some(OsString::from(key)),
-            None => None,
-        };
-
-        let mut command = ::std::process::Command::new(program);
-
-        command
-            .stdin(::std::process::Stdio::piped())
-            .stdout(::std::process::Stdio::piped())
-            .arg("--sign")
-            .arg("--armor")
-            .arg("--detach-sign")
-            .arg("-o")
-            .arg("-");
-
-        if key.is_some() {
-            let _ = command.arg("--default-key").arg(key.unwrap());
-        }
-
-        let mut child = command.spawn().expect("failed spawning gnupg");
-
-        {
-            let mut stdin = child.stdin.as_mut().expect("Failed to open stdin");
-            let mut hasher = repo.config().hashing_algorithm().hasher();
-            files_.hash(&mut *hasher).expect("failed hashing files");
-            let hash = hasher.result_box();
-            let encoded_hash = repo.config().encoding().encode(&hash);
-            stdin.write_all(encoded_hash.as_bytes()).expect("Failed to write to stdin");
-        }
-
-        let output = child.wait_with_output().expect("failed to read stdout");
-
-        if !output.status.success() {
-            eprintln!("Error: {}", String::from_utf8_lossy(&output.stderr));
-            return Err(String::from_utf8_lossy(&output.stderr).into());
-        } else {
-            let sig: OrderedFiles<_> = vec![(String::from(".signature"), Cursor::new(output.stdout))].into();
-            files + sig
-        }
-
-    } else {
-        files.boxed()
-    };
-
-    let record = container.new_record(files, link).expect("can't create record");
-
-    for (_, file) in used_files {
-        fs::remove_file(file).expect("can't remove file");
-    }
-
-    Ok(record)
-}
-
-fn reduce<MI, RCR: RecordContainerReduction<Record = repository::Record>>
-    (repo: &Repository<MI>, container: &RCR, request: &Request, query_expr: String) -> Response
-    where MI: repository::ModuleIterator<PathBuf, repository::Error> {
-    if let Some(vals) = request.get_param("reducers") {
-        let reducers_path = repo.path().join("reducers");
-        let reducers = vals.split(",").map(PathBuf::from)
-            .map(|p| if p.is_file() {
-                p
-            } else if reducers_path.join(&p).resolve_dir("/").unwrap().is_dir() {
-                let dir = reducers_path.join(&p).resolve_dir("/").unwrap();
-                dir
-            } else {
-                p
-            });
-        return reduce__(container, request, query_expr, reducers)
-    } else {
-        return reduce__(container, request, query_expr, repo)
-    }
-    // implementation
-    fn reduce__<RCR: RecordContainerReduction<Record = repository::Record>, SF: duktape::SourceFiles>
-        (container: &RCR, request: &Request, query_expr: String, source_files: SF) -> Response {
-            use jmespath;
-            let reducer = sit_core::reducers::duktape::DuktapeReducer::new(source_files).unwrap();
-            let query = match jmespath::compile(&query_expr) {
-                Ok(query) => query,
-                _ => return Response::empty_400(),
-            };
-            fn reduce_<RCR: RecordContainerReduction<Record = repository::Record>>
-                (container: &RCR, query: jmespath::Expression, mut reducer: duktape::DuktapeReducer<repository::Record>, state: serde_json::Value)-> Response {
-                    let state = container.initialize_state(state.as_object().unwrap().to_owned());
-                    let reduced = container.reduce_with_reducer_and_state(&mut reducer, state).unwrap();
-                    let data = jmespath::Variable::from(serde_json::Value::Object(reduced));
-                    let result = query.search(&data).unwrap();
-                    Response::json(&result)
-            }
-            if let Some(state) = request.get_param("state") {
-                reduce_(container, query, reducer, serde_json::from_str(&state).unwrap())
-            } else {
-                reduce_(container, query, reducer, serde_json::Value::Object(Default::default()))
-            }
-    }
-}
-
-
-pub fn start<A: ToSocketAddrs, MI: 'static + Send + Sync>(addr: A, config: sit_core::cfg::Configuration, repo: Repository<MI>, readonly: bool, overlays: Vec<&str>)
-    where MI: sit_core::repository::ModuleIterator<PathBuf, sit_core::repository::Error> {
-    let mut overlays: Vec<_> = overlays.iter().map(|o| PathBuf::from(o)).collect();
-    let assets: PathBuf = repo.path().join("web").into();
-    overlays.push(assets);
-    match repo.module_iter() {
-        Ok(iter) => {
-            for module_name in iter {
-                let module_name = module_name.unwrap();
-                overlays.push(repo.modules_path().join(module_name).join("web").into());
-            }
-        },
-        Err(sit_core::RepositoryError::OtherError(str)) => {
-            eprintln!("{}", str);
-            return;
-        },
-        Err(e) => {
-            eprintln!("error: {:?}", e);
-            return;
-        }
-    }
-    let repo_config = Config {
-      readonly,
-    };
-    start_server(addr, move |request|
-        router!(request,
-        (GET) (/user/config) => {
-          Response::json(&config)
-        },
-        (GET) (/config) => {
-           Response::json(&repo_config)
-        },
-        (GET) (/api/items/{filter_expr: String}/{query_expr: String}) => { // DEPRECATED
-        #[cfg(feature = "deprecated-items")] {
-            use jmespath;
-            use sit_core::record::RecordContainerReduction;
-            let items: Vec<_> = repo.item_iter().expect("can't list items").collect();
-            let mut reducer = Arc::new(Mutex::new(sit_core::reducers::duktape::DuktapeReducer::new(&repo).unwrap()));
-            let tl_reducer: ThreadLocal<RefCell<DuktapeReducer<sit_core::repository::Record>>>= ThreadLocal::new();
-
-            let filter_defined = filter_expr != "";
-            let filter = if filter_defined {
-                match jmespath::compile(&filter_expr) {
-                  Ok(filter) => filter,
-                  _ => return Response::empty_400(),
-                }
-            } else {
-                jmespath::compile("`true`").unwrap()
-            };
-            let query = match jmespath::compile(&query_expr) {
-                Ok(query) => query,
-                _ => return Response::empty_400(),
-            };
-
-            let result: Vec<_> =
-            items.into_par_iter()
-                  .map(|item| {
-                     let mut reducer = tl_reducer.get_or(|| Box::new(RefCell::new(reducer.lock().unwrap().clone()))).borrow_mut();
-                     reducer.reset_state();
-                     item.reduce_with_reducer(&mut *reducer).unwrap()
-                  }).map(|json| {
-                     let data = jmespath::Variable::from(serde_json::Value::Object(json));
-                     let result = if filter_defined {
-                        let res = filter.search(&data).unwrap();
-                        res.is_boolean() && res.as_boolean().unwrap()
-                     } else {
-                        true
-                     };
-                     if result {
-                        Some(query.search(&data).unwrap())
-                     } else {
-                        None
-                     }
-                  })
-                 .filter(Option::is_some).collect();
-            Response::json(&result)
-          }
-        #[cfg(not(feature = "deprecated-items"))] {
-             Response::not_found()
-        }
-        },
-        (GET) (/api/item/{id: String}/{query_expr: String}) => { // DEPRECATED 
-        #[cfg(feature = "deprecated-items")] {
-            use jmespath;
-            use sit_core::record::RecordContainerReduction;
-            use sit_core::Item;
-            let mut reducer = sit_core::reducers::duktape::DuktapeReducer::new(&repo).unwrap();
-            let query = match jmespath::compile(&query_expr) {
-                Ok(query) => query,
-                _ => return Response::empty_400(),
-            };
-            let item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
-                Some(item) => item,
-                _ => return Response::empty_404(),
-            };
-            let reduced = item.reduce_with_reducer(&mut reducer).unwrap();
-            let data = jmespath::Variable::from(serde_json::Value::Object(reduced));
-            let result = query.search(&data).unwrap();
-            Response::json(&result)
-        }
-        #[cfg(not(feature = "deprecated-items"))] {
-             Response::not_found()
-        }
-        },
-        (GET) (/api/{roots: String}/reduce/{query_expr: String}) => {
-            let container = repo.fixed_roots(roots.split(","));
-            reduce(&repo, &container, &request, query_expr)
-        },
-        (GET) (/api/reduce/{query_expr: String}) => {
-            reduce(&repo, &repo, &request, query_expr)
-        },
-        (GET) (/api/item/{id: String}/{record: String}/files) => { // DEPRECATED
-        #[cfg(feature = "deprecated-items")] {
-            use sit_core::{Record, Item};
-            let item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
-                Some(item) => item,
-                None => return Response::empty_404(),
-            };
-            let record = match ::itertools::Itertools::flatten(item.record_iter().unwrap()).find(|r| r.encoded_hash() == record) {
-               Some(record) => record,
-               None => return Response::empty_404(),
-            };
-            let files: Vec<_> = record.file_iter().map(|(name, _)| name).collect();
-            Response::json(&files)
-        }
-        #[cfg(not(feature = "deprecated-items"))] {
-             Response::not_found()
-        }
-        },
-        (GET) (/api/record/{record: String}/files) => {
-            use sit_core::Record;
-            let record = match repo.record(record) {
-               Some(record) => record,
-               None => return Response::empty_404(),
-            };
-            let files: Vec<_> = record.file_iter().map(|(name, _)| name).collect();
-            Response::json(&files)
-        },
-        (POST) (/api/item) => {
-        #[cfg(feature = "deprecated-items")] { // DEPRECATED
-           if readonly { return Response::empty_404(); }
-           use sit_core::Item;
-           let item = repo.new_item().expect("can't create item");
-           Response::json(&item.id())
-        }
-        #[cfg(not(feature = "deprecated-items"))] {
-             Response::not_found()
-        }
-        },
-        (POST) (/api/item/{id: String}/records) => { // DEPRECATED
-        #[cfg(feature = "deprecated-items")] {
-           if readonly { return Response::empty_404(); }
-           use sit_core::{Item, Record};
-           let mut item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
-                Some(item) => item,
-                None => return Response::empty_404(),
-           };
-
-           match new_record(&item, &request, &repo, &config) {
-               Ok(record) => Response::json(&record.encoded_hash()),
-               Err(_) => Response::text("Error").with_status_code(500),
-           }
-        }
-        #[cfg(not(feature = "deprecated-items"))] {
-             Response::not_found()
-        }
-        },
-        (POST) (/api/records) => {
-           if readonly { return Response::empty_404(); }
-           use sit_core::Record;
-
-           match new_record(&repo, &request, &repo, &config) {
-               Ok(record) => Response::json(&record.encoded_hash()),
-               Err(_) => Response::text("Error").with_status_code(500),
-           }
-        },
-        _ => {
-        // Serve repository content
-        if request.url().starts_with("/repo/") {
-            let mut file = repo.path().join(&request.url()[6..]);
-            file = file.resolve_dir(repo.path()).unwrap_or(file);
-            if file.strip_prefix(repo.path()).is_err() {
-               return Response::empty_404();
-            }
-            if file.is_file() {
-                return path_to_response(file, request)
-            } else if file.is_dir() {
-                if let Ok(dir) = ::std::fs::read_dir(file) {
-                    let res = dir.filter(Result::is_ok)
-                       .map(Result::unwrap)
-                       .map(|e| if e.file_type().unwrap().is_dir() {
-                           let s = String::from(e.file_name().to_str().unwrap());
-                           (s + "/").into()
-                       } else {
-                           e.file_name()
-                       })
-                       .map(|s|
-                           String::from(s.to_str().unwrap())
-                       )
-                       .join("\n");
-                    return Response {
-                        status_code: 200,
-                        headers: vec![],
-                        data: ResponseBody::from_string(res),
-                        upgrade: None,
-                    }
-                }
-            }
-            return Response::empty_404()
-        }
-        // Serve built-in or overridden assets
-        let overriden_path =
-        overlays.iter().map(|o| o.join(&request.url()[1..]))
-                .find(|p| p.is_file());
-        if let Some(path) = overriden_path {
-           return path_to_response(path, request)
-        } else {
-            if let Some(file) = ASSETS.get(&PathBuf::from(&request.url()[1..])) {
-                let (response, hash) = file.into();
-                return response.with_etag(request, hash)
-            }
-        }
-        // Route the rest to /index.html for the web app to figure out
-        let custom_index =
-        overlays.iter().map(|o| o.join("index.html"))
-                .find(|p| p.is_file());
-
-        if let Some(index) = custom_index {
-           path_to_response(index, request)
-        } else {
-           let (response, hash) = ASSETS.get(&PathBuf::from("index.html")).unwrap().into();
-           response.with_etag(request, hash)
-        }
-      }
-      ))
-
-}
-
diff --git a/sit/Cargo.toml b/sit/Cargo.toml
index 391cbaf5..5fc8b91b 100644
--- a/sit/Cargo.toml
+++ b/sit/Cargo.toml
@@ -28,6 +28,13 @@ thread_local = "0.3"
 derive-error = "0.0"
 directories = "1.0"
 itertools = "0.7"
+rouille = { version = "2.2.0", optional = true }
+mime_guess = { version = "1.8", optional = true }
+digest = { version = "0.7", optional = true }
+blake2 = { version = "0.7", optional = true }
+hex = { version = "0.3", optional = true }
+lazy_static = { version = "1.0", optional = true }
+serde_derive = { version = "1.0", optional = true }
 sit-core = { path = "../sit-core", version = "0.5.0-pre", features = ["git"] }
 
 [dev-dependencies]
@@ -35,7 +42,12 @@ cli_test_dir = "0.1.5"
 git2 = { version = "0.7", default-features = false }
 remove_dir_all = "0.5"
 
+[build-dependencies]
+include_dir = "0.1"
+fs_extra = "1.1"
+
 [features]
-default = ["deprecated-items"]
+default = ["deprecated-items", "web"]
 windows7 = ["sit-core/windows7"]
 deprecated-items = ["sit-core/deprecated-item-api"]
+web = ["rouille", "mime_guess", "digest", "blake2", "hex", "lazy_static", "serde_derive" ]
diff --git a/sit-web/build.rs b/sit/build.rs
similarity index 86%
rename from sit-web/build.rs
rename to sit/build.rs
index 3d4ef317..aeb3431c 100644
--- a/sit-web/build.rs
+++ b/sit/build.rs
@@ -8,7 +8,7 @@ use include_dir::include_dir;
 
 fn main() {
     let outdir = env::var("OUT_DIR").unwrap();
-    let dest_path = Path::new(&outdir).join("assets.rs");
+    let dest_path = Path::new(&outdir).join("web_assets.rs");
     let webapp = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap()).join("webapp");
     include_dir(webapp.to_str().unwrap())
         .as_variable("FILES")
diff --git a/sit/src/command_web.rs b/sit/src/command_web.rs
new file mode 100644
index 00000000..3e237e6d
--- /dev/null
+++ b/sit/src/command_web.rs
@@ -0,0 +1,516 @@
+use clap::{self, ArgMatches};
+use sit_core::{Repository, cfg::Configuration, repository};
+use std::path::PathBuf;
+
+pub fn command<MI: 'static + Send + Sync >(repo: Repository<MI>, matches: &ArgMatches, main_matches: ArgMatches<'static>, config: Configuration) -> i32 
+    where MI: repository::ModuleIterator<PathBuf, repository::Error> {
+    let listen = matches.value_of("listen").unwrap();
+    let readonly = matches.is_present("readonly");
+    let overlays: Vec<_> = matches.values_of("overlay").unwrap_or(clap::Values::default()).collect();
+    println!("Serving on {}", listen);
+    webapp::start(listen, config, repo, readonly, overlays, main_matches);
+    return 0;
+}
+
+mod webapp {
+    #[allow(dead_code)]
+    mod assets {
+        include!(concat!(env!("OUT_DIR"), "/web_assets.rs"));
+
+        use rouille::{Response, ResponseBody};
+        use mime_guess::get_mime_type_str;
+        use std::path::PathBuf;
+        use blake2::Blake2b;
+        use digest::{Input, VariableOutput};
+        use hex;
+
+        impl<'a> Into<(Response, String)> for &'a File {
+            fn into(self) -> (Response, String) {
+                let mut hasher = Blake2b::new(20).unwrap();
+                let mut result = vec![0; 20];
+                hasher.process(self.contents);
+                let hash = hex::encode(hasher.variable_result(&mut result).unwrap());
+                (match get_mime_type_str(PathBuf::from(self.name()).extension().unwrap().to_str().unwrap()) {
+                    None => Response {
+                        status_code: 200,
+                        headers: vec![("Content-Type".into(), "application/octet-stream".into())],
+                        data: ResponseBody::from_data(self.contents),
+                        upgrade: None,
+                    },
+                    Some(content_type) => Response {
+                        status_code: 200,
+                        headers: vec![("Content-Type".into(), content_type.into())],
+                        data: ResponseBody::from_data(self.contents),
+                        upgrade: None,
+                    },
+                }, hash)
+            }
+        }
+
+        use std::collections::HashMap;
+
+        lazy_static! {
+            pub static ref ASSETS: HashMap<PathBuf, File> = {
+                let mut map = HashMap::new();
+                let mut prefix = PathBuf::from(FILES.find("index.html").unwrap().path());
+                prefix.pop();
+                for entry in FILES.walk() {
+                    match entry {
+                        DirEntry::File(f) => {
+                            let path = PathBuf::from(f.path().strip_prefix(&prefix).unwrap());
+                            map.insert(path.clone(), f.clone());
+                            let super_path = PathBuf::from("super").join(path);
+                            map.insert(super_path, f.clone());
+                        },
+                        _ => (),
+                    }
+                }
+                map
+            };
+        }
+
+    }
+    use self::assets::ASSETS;
+
+    use rouille::{start_server, Request, Response, ResponseBody};
+    use rouille::input::multipart::get_multipart_input;
+
+    use std::path::PathBuf;
+    use std::fs;
+    use std::net::ToSocketAddrs;
+
+    use sit_core::{Repository, repository, reducers::duktape::{self, DuktapeReducer}, record::OrderedFiles,
+    record::{RecordContainer, RecordContainerReduction, RecordOwningContainer}, path::{HasPath, ResolvePath}};
+    use std::io::Cursor;
+
+    use mime_guess::get_mime_type_str;
+
+    use std::ffi::OsString;
+
+    use rayon::prelude::*;
+
+    use blake2::Blake2b;
+    use digest::{Input, VariableOutput};
+    use hex;
+
+    use serde_json;
+
+    use std::sync::{Arc, Mutex};
+    use std::cell::RefCell;
+    use thread_local::ThreadLocal;
+    use clap::ArgMatches;
+
+    fn path_to_response<P: Into<PathBuf>>(path: P, request: &Request) -> Response {
+        let path: PathBuf = path.into();
+
+        let mut file = fs::File::open(&path).unwrap();
+        let mut buf = Vec::with_capacity(file.metadata().unwrap().len() as usize);
+        use std::io::Read;
+        file.read_to_end(&mut buf).unwrap();
+
+
+        let mut hasher = Blake2b::new(20).unwrap();
+        let mut result = vec![0; 20];
+        hasher.process(&buf);
+        let hash = hex::encode(hasher.variable_result(&mut result).unwrap());
+
+        match get_mime_type_str(path.extension().unwrap_or(&OsString::new()).to_str().unwrap()) {
+            None => Response {
+                status_code: 200,
+                headers: vec![("Content-Type".into(), "application/octet-stream".into())],
+                data: ResponseBody::from_data(buf),
+                upgrade: None,
+            },
+            Some(content_type) => Response {
+                status_code: 200,
+                headers: vec![("Content-Type".into(), content_type.into())],
+                data: ResponseBody::from_data(buf),
+                upgrade: None,
+            },
+        }.with_etag(request, hash)
+    }
+
+
+    use itertools::Itertools;
+    use sit_core;
+
+#[derive(Serialize)]
+    struct Config {
+        readonly: bool,
+    }
+
+
+    fn new_record<C: RecordOwningContainer, MI>(container: &C, request: &Request, repo: &Repository<MI>, config: &sit_core::cfg::Configuration, matches: &ArgMatches) -> Result<C::Record, String> {
+        let mut multipart = get_multipart_input(request).expect("multipart request");
+        let mut link = true;
+        let mut used_files = vec![];
+
+        loop {
+            let part = multipart.next();
+            if part.is_none() {
+                break;
+            }
+            let mut field = part.unwrap();
+            loop {
+                let path = {
+                    let mut file = field.data.as_file().expect("files only");
+                    let saved_file = file.save().temp().into_result().expect("can't save file");
+                    saved_file.path
+                };
+                if field.name.starts_with(".prev/") {
+                    link = false;
+                }
+                used_files.push((field.name.clone(), path));
+                match field.next_entry_inplace() {
+                    Ok(Some(_)) => continue,
+                    Ok(None) => break,
+                    Err(e) => panic!(e),
+                }
+            }
+        }
+
+        let files: OrderedFiles<_> = used_files.iter().map(|(n, p)| (n.clone(), fs::File::open(p).expect("can't open saved file"))).into();
+        let files_: OrderedFiles<_> = used_files.iter().map(|(n, p)| (n.clone(), fs::File::open(p).expect("can't open saved file"))).into();
+
+        let files: OrderedFiles<_> = if config.signing.enabled {
+            use std::ffi::OsString;
+            use std::io::Write;
+            let program = super::super::gnupg(matches, &config).unwrap();
+            let key = match config.signing.key.clone() {
+                Some(key) => Some(OsString::from(key)),
+                None => None,
+            };
+
+            let mut command = ::std::process::Command::new(program);
+
+            command
+                .stdin(::std::process::Stdio::piped())
+                .stdout(::std::process::Stdio::piped())
+                .arg("--sign")
+                .arg("--armor")
+                .arg("--detach-sign")
+                .arg("-o")
+                .arg("-");
+
+            if key.is_some() {
+                let _ = command.arg("--default-key").arg(key.unwrap());
+            }
+
+            let mut child = command.spawn().expect("failed spawning gnupg");
+
+            {
+                let mut stdin = child.stdin.as_mut().expect("Failed to open stdin");
+                let mut hasher = repo.config().hashing_algorithm().hasher();
+                files_.hash(&mut *hasher).expect("failed hashing files");
+                let hash = hasher.result_box();
+                let encoded_hash = repo.config().encoding().encode(&hash);
+                stdin.write_all(encoded_hash.as_bytes()).expect("Failed to write to stdin");
+            }
+
+            let output = child.wait_with_output().expect("failed to read stdout");
+
+            if !output.status.success() {
+                eprintln!("Error: {}", String::from_utf8_lossy(&output.stderr));
+                return Err(String::from_utf8_lossy(&output.stderr).into());
+            } else {
+                let sig: OrderedFiles<_> = vec![(String::from(".signature"), Cursor::new(output.stdout))].into();
+                files + sig
+            }
+
+        } else {
+            files.boxed()
+        };
+
+        let record = container.new_record(files, link).expect("can't create record");
+
+        for (_, file) in used_files {
+            fs::remove_file(file).expect("can't remove file");
+        }
+
+        Ok(record)
+    }
+
+    fn reduce<MI, RCR: RecordContainerReduction<Record = repository::Record>>
+        (repo: &Repository<MI>, container: &RCR, request: &Request, query_expr: String) -> Response
+            where MI: repository::ModuleIterator<PathBuf, repository::Error> {
+                if let Some(vals) = request.get_param("reducers") {
+                    let reducers_path = repo.path().join("reducers");
+                    let reducers = vals.split(",").map(PathBuf::from)
+                        .map(|p| if p.is_file() {
+                            p
+                        } else if reducers_path.join(&p).resolve_dir("/").unwrap().is_dir() {
+                            let dir = reducers_path.join(&p).resolve_dir("/").unwrap();
+                            dir
+                        } else {
+                            p
+                        });
+                    return reduce__(container, request, query_expr, reducers)
+                } else {
+                    return reduce__(container, request, query_expr, repo)
+                }
+                // implementation
+                fn reduce__<RCR: RecordContainerReduction<Record = repository::Record>, SF: duktape::SourceFiles>
+                    (container: &RCR, request: &Request, query_expr: String, source_files: SF) -> Response {
+                        use jmespath;
+                        let reducer = sit_core::reducers::duktape::DuktapeReducer::new(source_files).unwrap();
+                        let query = match jmespath::compile(&query_expr) {
+                            Ok(query) => query,
+                            _ => return Response::empty_400(),
+                        };
+                        fn reduce_<RCR: RecordContainerReduction<Record = repository::Record>>
+                            (container: &RCR, query: jmespath::Expression, mut reducer: duktape::DuktapeReducer<repository::Record>, state: serde_json::Value)-> Response {
+                                let state = container.initialize_state(state.as_object().unwrap().to_owned());
+                                let reduced = container.reduce_with_reducer_and_state(&mut reducer, state).unwrap();
+                                let data = jmespath::Variable::from(serde_json::Value::Object(reduced));
+                                let result = query.search(&data).unwrap();
+                                Response::json(&result)
+                            }
+                        if let Some(state) = request.get_param("state") {
+                            reduce_(container, query, reducer, serde_json::from_str(&state).unwrap())
+                        } else {
+                            reduce_(container, query, reducer, serde_json::Value::Object(Default::default()))
+                        }
+                    }
+            }
+
+
+    pub fn start<A: ToSocketAddrs, MI: 'static + Send + Sync>(addr: A, config: sit_core::cfg::Configuration, repo: Repository<MI>, readonly: bool, overlays: Vec<&str>, matches: ArgMatches<'static>)
+        where MI: sit_core::repository::ModuleIterator<PathBuf, sit_core::repository::Error> {
+            let mut overlays: Vec<_> = overlays.iter().map(|o| PathBuf::from(o)).collect();
+            let assets: PathBuf = repo.path().join("web").into();
+            overlays.push(assets);
+            match repo.module_iter() {
+                Ok(iter) => {
+                    for module_name in iter {
+                        let module_name = module_name.unwrap();
+                        overlays.push(repo.modules_path().join(module_name).join("web").into());
+                    }
+                },
+                Err(sit_core::RepositoryError::OtherError(str)) => {
+                    eprintln!("{}", str);
+                    return;
+                },
+                Err(e) => {
+                    eprintln!("error: {:?}", e);
+                    return;
+                }
+            }
+            let repo_config = Config {
+                readonly,
+            };
+            start_server(addr, move |request|
+                         router!(request,
+                                 (GET) (/user/config) => {
+                                     Response::json(&config)
+                                 },
+                                 (GET) (/config) => {
+                                     Response::json(&repo_config)
+                                 },
+                                 (GET) (/api/items/{filter_expr: String}/{query_expr: String}) => { // DEPRECATED
+                                     #[cfg(feature = "deprecated-items")] {
+                                         use jmespath;
+                                         use sit_core::record::RecordContainerReduction;
+                                         let items: Vec<_> = repo.item_iter().expect("can't list items").collect();
+                                         let mut reducer = Arc::new(Mutex::new(sit_core::reducers::duktape::DuktapeReducer::new(&repo).unwrap()));
+                                         let tl_reducer: ThreadLocal<RefCell<DuktapeReducer<sit_core::repository::Record>>>= ThreadLocal::new();
+
+                                         let filter_defined = filter_expr != "";
+                                         let filter = if filter_defined {
+                                             match jmespath::compile(&filter_expr) {
+                                                 Ok(filter) => filter,
+                                                 _ => return Response::empty_400(),
+                                             }
+                                         } else {
+                                             jmespath::compile("`true`").unwrap()
+                                         };
+                                         let query = match jmespath::compile(&query_expr) {
+                                             Ok(query) => query,
+                                             _ => return Response::empty_400(),
+                                         };
+
+                                         let result: Vec<_> =
+                                             items.into_par_iter()
+                                             .map(|item| {
+                                                 let mut reducer = tl_reducer.get_or(|| Box::new(RefCell::new(reducer.lock().unwrap().clone()))).borrow_mut();
+                                                 reducer.reset_state();
+                                                 item.reduce_with_reducer(&mut *reducer).unwrap()
+                                             }).map(|json| {
+                                                 let data = jmespath::Variable::from(serde_json::Value::Object(json));
+                                                 let result = if filter_defined {
+                                                     let res = filter.search(&data).unwrap();
+                                                     res.is_boolean() && res.as_boolean().unwrap()
+                                                 } else {
+                                                     true
+                                                 };
+                                                 if result {
+                                                     Some(query.search(&data).unwrap())
+                                                 } else {
+                                                     None
+                                                 }
+                                             })
+                                         .filter(Option::is_some).collect();
+                                         Response::json(&result)
+                                     }
+                                     #[cfg(not(feature = "deprecated-items"))] {
+                                         Response::not_found()
+                                     }
+                                 },
+                                 (GET) (/api/item/{id: String}/{query_expr: String}) => { // DEPRECATED 
+                                     #[cfg(feature = "deprecated-items")] {
+                                         use jmespath;
+                                         use sit_core::record::RecordContainerReduction;
+                                         use sit_core::Item;
+                                         let mut reducer = sit_core::reducers::duktape::DuktapeReducer::new(&repo).unwrap();
+                                         let query = match jmespath::compile(&query_expr) {
+                                             Ok(query) => query,
+                                             _ => return Response::empty_400(),
+                                         };
+                                         let item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
+                                             Some(item) => item,
+                                             _ => return Response::empty_404(),
+                                         };
+                                         let reduced = item.reduce_with_reducer(&mut reducer).unwrap();
+                                         let data = jmespath::Variable::from(serde_json::Value::Object(reduced));
+                                         let result = query.search(&data).unwrap();
+                                         Response::json(&result)
+                                     }
+                                     #[cfg(not(feature = "deprecated-items"))] {
+                                         Response::not_found()
+                                     }
+                                 },
+                                 (GET) (/api/{roots: String}/reduce/{query_expr: String}) => {
+                                     let container = repo.fixed_roots(roots.split(","));
+                                     reduce(&repo, &container, &request, query_expr)
+                                 },
+                                 (GET) (/api/reduce/{query_expr: String}) => {
+                                     reduce(&repo, &repo, &request, query_expr)
+                                 },
+                                 (GET) (/api/item/{id: String}/{record: String}/files) => { // DEPRECATED
+                                     #[cfg(feature = "deprecated-items")] {
+                                         use sit_core::{Record, Item};
+                                         let item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
+                                             Some(item) => item,
+                                             None => return Response::empty_404(),
+                                         };
+                                         let record = match ::itertools::Itertools::flatten(item.record_iter().unwrap()).find(|r| r.encoded_hash() == record) {
+                                             Some(record) => record,
+                                             None => return Response::empty_404(),
+                                         };
+                                         let files: Vec<_> = record.file_iter().map(|(name, _)| name).collect();
+                                         Response::json(&files)
+                                     }
+                                     #[cfg(not(feature = "deprecated-items"))] {
+                                         Response::not_found()
+                                     }
+                                 },
+                                 (GET) (/api/record/{record: String}/files) => {
+                                     use sit_core::Record;
+                                     let record = match repo.record(record) {
+                                         Some(record) => record,
+                                         None => return Response::empty_404(),
+                                     };
+                                     let files: Vec<_> = record.file_iter().map(|(name, _)| name).collect();
+                                     Response::json(&files)
+                                 },
+                                 (POST) (/api/item) => {
+                                     #[cfg(feature = "deprecated-items")] { // DEPRECATED
+                                         if readonly { return Response::empty_404(); }
+                                         use sit_core::Item;
+                                         let item = repo.new_item().expect("can't create item");
+                                         Response::json(&item.id())
+                                     }
+                                     #[cfg(not(feature = "deprecated-items"))] {
+                                         Response::not_found()
+                                     }
+                                 },
+                                 (POST) (/api/item/{id: String}/records) => { // DEPRECATED
+                                     #[cfg(feature = "deprecated-items")] {
+                                         if readonly { return Response::empty_404(); }
+                                         use sit_core::{Item, Record};
+                                         let mut item = match repo.item_iter().unwrap().find(|i| i.id() == id) {
+                                             Some(item) => item,
+                                             None => return Response::empty_404(),
+                                         };
+
+                                         match new_record(&item, &request, &repo, &config, &matches) {
+                                             Ok(record) => Response::json(&record.encoded_hash()),
+                                             Err(_) => Response::text("Error").with_status_code(500),
+                                         }
+                                     }
+                                     #[cfg(not(feature = "deprecated-items"))] {
+                                         Response::not_found()
+                                     }
+                                 },
+                                 (POST) (/api/records) => {
+                                     if readonly { return Response::empty_404(); }
+                                     use sit_core::Record;
+
+                                     match new_record(&repo, &request, &repo, &config, &matches) {
+                                         Ok(record) => Response::json(&record.encoded_hash()),
+                                         Err(_) => Response::text("Error").with_status_code(500),
+                                     }
+                                 },
+                                 _ => {
+                                     // Serve repository content
+                                     if request.url().starts_with("/repo/") {
+                                         let mut file = repo.path().join(&request.url()[6..]);
+                                         file = file.resolve_dir(repo.path()).unwrap_or(file);
+                                         println!("{:?} {:?}", repo.path(), file);
+                                         if file.strip_prefix(repo.path()).is_err() {
+                                             return Response::empty_404();
+                                         }
+                                         if file.is_file() {
+                                             return path_to_response(file, request)
+                                         } else if file.is_dir() {
+                                             if let Ok(dir) = ::std::fs::read_dir(file) {
+                                                 let res = dir.filter(Result::is_ok)
+                                                     .map(Result::unwrap)
+                                                     .map(|e| if e.file_type().unwrap().is_dir() {
+                                                         let s = String::from(e.file_name().to_str().unwrap());
+                                                         (s + "/").into()
+                                                     } else {
+                                                         e.file_name()
+                                                     })
+                                                 .map(|s|
+                                                      String::from(s.to_str().unwrap())
+                                                     )
+                                                     .join("\n");
+                                                 return Response {
+                                                     status_code: 200,
+                                                     headers: vec![],
+                                                     data: ResponseBody::from_string(res),
+                                                     upgrade: None,
+                                                 }
+                                             }
+                                         }
+                                         return Response::empty_404()
+                                     }
+                                     // Serve built-in or overridden assets
+                                     let overriden_path =
+                                         overlays.iter().map(|o| o.join(&request.url()[1..]))
+                                         .find(|p| p.is_file());
+                                     if let Some(path) = overriden_path {
+                                         return path_to_response(path, request)
+                                     } else {
+                                         if let Some(file) = ASSETS.get(&PathBuf::from(&request.url()[1..])) {
+                                             let (response, hash) = file.into();
+                                             return response.with_etag(request, hash)
+                                         }
+                                     }
+                                     // Route the rest to /index.html for the web app to figure out
+                                     let custom_index =
+                                         overlays.iter().map(|o| o.join("index.html"))
+                                         .find(|p| p.is_file());
+
+                                     if let Some(index) = custom_index {
+                                         path_to_response(index, request)
+                                     } else {
+                                         let (response, hash) = ASSETS.get(&PathBuf::from("index.html")).unwrap().into();
+                                         response.with_etag(request, hash)
+                                     }
+                                 }
+            ))
+
+        }
+
+}
diff --git a/sit/src/main.rs b/sit/src/main.rs
index a4ee1c6b..8fd17315 100644
--- a/sit/src/main.rs
+++ b/sit/src/main.rs
@@ -32,6 +32,8 @@ mod command_records;
 mod command_external;
 mod command_jmespath;
 mod command_integrity;
+#[cfg(feature="web")]
+mod command_web;
 
 mod cli;
 
@@ -59,6 +61,24 @@ extern crate thread_local;
 extern crate directories;
 extern crate itertools;
 
+#[cfg(feature="web")]
+#[macro_use]
+extern crate rouille;
+#[cfg(feature="web")]
+extern crate mime_guess;
+#[cfg(feature="web")]
+extern crate digest;
+#[cfg(feature="web")]
+extern crate blake2;
+#[cfg(feature="web")]
+extern crate hex;
+#[cfg(feature="web")]
+#[macro_use]
+extern crate lazy_static;
+#[cfg(feature="web")]
+#[macro_use]
+extern crate serde_derive;
+
 use std::collections::HashMap;
 pub fn get_named_expression<S: AsRef<str>, MI>(name: S, repo: &sit_core::Repository<MI>,
                                        repo_path: S, exprs: &HashMap<String, String>) -> Option<String> {
@@ -116,8 +136,8 @@ fn main_with_result(allow_external_subcommands: bool) -> i32 {
         .settings(&[clap::AppSettings::ColoredHelp, clap::AppSettings::ColorAuto])
         .arg(Arg::with_name("working_directory")
             .short("d")
-            .default_value(cwd.to_str().unwrap())
-            .help("Working directory"))
+            .takes_value(true)
+            .help("Working directory (defaults to current directory)"))
         .arg(Arg::with_name("repository")
             .short("r")
             .long("repository")
@@ -376,7 +396,24 @@ fn main_with_result(allow_external_subcommands: bool) -> i32 {
                 .multiple(true)
                 .conflicts_with("help")
                 .help("Arguments to parse"))
-            .about("Parses arguments against a specification given on stdin"));
+            .about("Parses arguments against a specification given on stdin"))
+        .conditionally(cfg!(feature = "web"), |app|
+        app.subcommand(SubCommand::with_name("web")
+            .settings(&[clap::AppSettings::ColoredHelp, clap::AppSettings::ColorAuto])
+            .about("HTTP API server providing access to the repository")
+            .arg(Arg::with_name("readonly")
+                 .long("readonly")
+                 .help("Read-only instance of sit-web (no new items or records can be created)"))
+            .arg(Arg::with_name("overlay")
+                 .short("o")
+                 .long("overlay")
+                 .takes_value(true)
+                 .multiple(true)
+                 .help("Path to an additional [besides standard ones] web overlay"))
+            .arg(Arg::with_name("listen")
+                 .default_value("127.0.0.1:8080")
+                 .help("Listen on IP:PORT"))));
+
 
     if allow_external_subcommands {
         app = app.setting(clap::AppSettings::AllowExternalSubcommands);
@@ -404,7 +441,7 @@ fn main_with_result(allow_external_subcommands: bool) -> i32 {
         return 1;
     }
 
-    let working_dir = PathBuf::from(matches.value_of("working_directory").unwrap());
+    let working_dir = PathBuf::from(matches.value_of("working_directory").unwrap_or(cwd.to_str().unwrap()));
     let dot_sit = working_dir.join(".sit");
 
     if let Some(matches) = matches.subcommand_matches("config") {
@@ -455,14 +492,14 @@ fn main_with_result(allow_external_subcommands: bool) -> i32 {
         return match repo.config().clone().extra().get("external_module_manager") {
             Some(serde_json::Value::String(name)) => {
                 let original_repo = repo.clone();
-                do_matches(matches.clone(), repo.with_module_iterator(ScriptModule(original_repo, &cwd, name.to_string())), cwd.clone(), config, config_path)
+                do_matches(matches.clone(), repo.with_module_iterator(ScriptModule(original_repo, cwd.clone(), name.to_string())), cwd.clone(), config, config_path)
             }
             _ => do_matches(matches.clone(), repo, cwd.clone(), config, config_path),
         };
 
-        fn do_matches<MI: Send + Sync>(matches: ArgMatches, repo: sit_core::Repository<MI>, cwd: PathBuf, config: cfg::Configuration, config_path: &str) -> i32
+        fn do_matches<MI: 'static + Send + Sync>(matches: ArgMatches<'static>, repo: sit_core::Repository<MI>, cwd: PathBuf, config: cfg::Configuration, config_path: &str) -> i32
             where MI: sit_core::repository::ModuleIterator<PathBuf, sit_core::repository::Error> {
-            let working_dir = PathBuf::from(matches.value_of("working_directory").unwrap());
+            let working_dir = PathBuf::from(matches.value_of("working_directory").unwrap_or(cwd.to_str().unwrap()));
             let canonical_working_dir = dunce::canonicalize(&working_dir).expect("can't canonicalize working directory");
             if let Some(_) = matches.subcommand_matches("modules") {
                 match repo.module_iter() {
@@ -534,6 +571,10 @@ fn main_with_result(allow_external_subcommands: bool) -> i32 {
                 return command_integrity::command(repo);
             }
 
+            if let Some(web_matches) = matches.subcommand_matches("web") {
+                return command_web::command(repo, web_matches, matches.clone(), config);
+            }
+
             match command_external::command(&matches, repo, &cwd) {
                 Err(_) => {
                     return main_with_result(false)
diff --git a/sit-web/webapp/favicon.ico b/sit/webapp/favicon.ico
similarity index 100%
rename from sit-web/webapp/favicon.ico
rename to sit/webapp/favicon.ico
diff --git a/sit-web/webapp/index.html b/sit/webapp/index.html
similarity index 100%
rename from sit-web/webapp/index.html
rename to sit/webapp/index.html
-- 
2.16.4

